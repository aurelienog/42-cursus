ğŸ§  Â¿QuÃ© es una lista enlazada?

Una lista enlazada es una estructura de datos formada por nodos.
Cada nodo tiene:

typedef struct s_list
{
    void            *content;
    struct s_list   *next;
} t_list;

ğŸ”¹ Cada nodo contiene:

content â†’ el dato (puede ser lo que sea)

next â†’ un puntero al siguiente nodo

ğŸ“Œ A diferencia de un array:

No estÃ¡ en memoria contigua

No tiene tamaÃ±o fijo

Se recorre nodo por nodo


ğŸ§© El puntero doble: t_list **lst

Esto es CLAVE para entender tus funciones.

â“ Â¿Por quÃ© t_list **lst?

Porque queremos modificar la cabeza de la lista.

Si usÃ¡ramos:

void ft_lstadd_front(t_list *lst)


âŒ Solo modificarÃ­amos una copia del puntero.

Con:

t_list **lst


âœ”ï¸ Podemos cambiar a quÃ© nodo apunta la lista.


Regla de ORO del C

C siempre pasa los argumentos por valor

Eso incluye los punteros.

ğŸ“Œ Pasar un puntero no significa pasar la variable original, sino una copia de su valor.

ğŸ”‘ 4ï¸âƒ£ Entoncesâ€¦ Â¿cÃ³mo cambio el puntero original?

ğŸ‘‰ Pasando la direcciÃ³n del puntero
ğŸ‘‰ Es decir: puntero a puntero

t_list **lst;

ğŸ¯ 9ï¸âƒ£ ConclusiÃ³n que debes memorizar

ğŸ‘‰ Si una funciÃ³n necesita cambiar el primer nodo de la lista, usa t_list **


PUNTEROS VOID
âœ”ï¸ void * â†’ el compilador no sabe el tamaÃ±o del objeto apuntado
NO sabe:
si apunta a 1 byte
4 bytes
100 bytes
una estructura

CUIDADO :
void *vp;
vp + 1  â†’ âŒ ERROR
ğŸ‘‰ El compilador no puede calcular sizeof(*vp)
ğŸ‘‰ No sabe cuÃ¡ntos bytes avanzar

âœ”ï¸ unsigned char * â†’ acceso byte a byte
âœ”ï¸ No cambia el tamaÃ±o del dato original
âœ”ï¸ Sirve para:
serializaciÃ³n
buffers
manejo de memoria cruda

Recursos :
ğŸ“º Jacob Sorber â€“ Memory in C (YouTube)

Busca:

â€œDynamic Memory Allocation in Câ€
â€œmalloc and free explainedâ€
â€œStack vs Heapâ€

ğŸ‘‰ QuÃ© debes aprender aquÃ­:

Diferencia stack / heap
QuÃ© pasa cuando una funciÃ³n termina
Por quÃ© devolver un puntero local es un error

ğŸ’¡ Si solo ves un canal, que sea este.

ğŸ§± 3. Stack vs Heap (clave para libft)
ğŸ“º CodeVault â€“ Stack vs Heap
VÃ­deo corto, muy claro.

Visualizar memoria (muy importante)
ğŸŒ Python Tutor (web)

ğŸ‘‰ https://pythontutor.com/c.html

ğŸ“º Tutorial Valgrind bÃ¡sico
Aprende a reconocer:
definitely lost
invalid read
invalid write
ğŸ‘‰ Si entiendes Valgrind, libft no te puede tumbar por memoria.
