UPDATE

PUNTEROS VOID
âœ”ï¸ void * â†’ el compilador no sabe el tamaÃ±o del objeto apuntado
NO sabe:
si apunta a 1 byte
4 bytes
100 bytes
una estructura

CUIDADO :
void *vp;
vp + 1  â†’ âŒ ERROR
ğŸ‘‰ El compilador no puede calcular sizeof(*vp)
ğŸ‘‰ No sabe cuÃ¡ntos bytes avanzar

âœ”ï¸ unsigned char * â†’ acceso byte a byte
âœ”ï¸ No cambia el tamaÃ±o del dato original
âœ”ï¸ Sirve para:
serializaciÃ³n
buffers
manejo de memoria cruda

Recursos :
ğŸ“º Jacob Sorber â€“ Memory in C (YouTube)

Busca:

â€œDynamic Memory Allocation in Câ€
â€œmalloc and free explainedâ€
â€œStack vs Heapâ€

ğŸ‘‰ QuÃ© debes aprender aquÃ­:

Diferencia stack / heap
QuÃ© pasa cuando una funciÃ³n termina
Por quÃ© devolver un puntero local es un error

ğŸ’¡ Si solo ves un canal, que sea este.

ğŸ§± 3. Stack vs Heap (clave para libft)
ğŸ“º CodeVault â€“ Stack vs Heap
VÃ­deo corto, muy claro.

Visualizar memoria (muy importante)
ğŸŒ Python Tutor (web)

ğŸ‘‰ https://pythontutor.com/c.html

ğŸ“º Tutorial Valgrind bÃ¡sico
Aprende a reconocer:
definitely lost
invalid read
invalid write
ğŸ‘‰ Si entiendes Valgrind, libft no te puede tumbar por memoria.
